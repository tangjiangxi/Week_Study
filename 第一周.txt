1. 原型
创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法

使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。它不必向构造函数那样必须在内部定义对象实例的信息，他可以从外部添加共享的实例信息。

function Tang(){}
//向该函数的原型中添加属性和方法
Tang.prototype.name="tangjiangxi";
//添加方法
Tang.prototype.sayName=functionn(){
	alert("tangjiangxi");
};
var person=new Tang();
person.sayName     //   tangjiangxi 
2.原型链
js高层162页给出概念： 原型链是实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。
js中继承与java中继承的区别：js不存在什么接口继承，js的继承主要就依赖原型链来实现的。
实现的基本模式：js高程163页

function SuperType(){
	this.propety=true;
};
SuperType.prototype.getSuperValue=function(){
	return this.property;
};
functon SubType(){
	this.subproperty=false;
};
//继承SuperType
SubType.prototype=new SuperType();
SubType.prototype.getSubValue=function(){
	return this.subProperty;
};
var instance=new SubType()
alert(instance.getSuperValue); //true
3.js闭包
js高程178页
简单概念（并不能说简单）：闭包指的是有权访问另外一个函数作用域中的变量函数。
在用到闭包的时候就不得不讲解下作用域了。
作用域分为两种，即全局作用域与局部作用域。
这里提醒一个注意点，就是在函数中声明变量的时候，千万别把var省略了，这会让变量称为一个全局的，当然如果使用严格模式，会报错的
闭包的作用非常使用，可以为我们解决许多的问题。
1.可以让我们从外部读取内部的变量。
在函数内部在定义一个函数 内部函数是可以访问外部函数的变量的，我们把内部函数作为一个返回值，这样就可可以在外部访问内部的变量了。

function  f1(){
	var name="tangjiangxi";
	function f2(){
		alert(name);
	};
	return  f2;
}
var result=f1();  //这里返回的是内部函数
result(); //在调用一次就可以的到name的值了   输出为tangjiangxi
2.闭包中变量的值始终保存在变量中。
//借鉴他人博客

js code
function f1(){
　　var n = 999;
　　nAdd = function(){
　　　　n += 1;
　　}
　　function f2(){
　　　　console.log(n);
　　}
　　return f2;
}
var result = f1();
result();　　//从函数外部通过闭包f2获取到函数f1内部局部变量的值   999
nAdd();　　//从函数外部通过闭包修改局部变量n的值
result();　　//再次通过闭包f2获取到函数f1内部局部变量的值  1000
在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n 一直保存在内存中，并没有在f1调用后被自动清除。
为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，不会再调用结束后，被垃圾回收机制(garbage collection)回收。
这段代码中另一个值得注意的地方，就是‘nAdd=function(){n+=1}’这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数(anonymous function)，而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

使用闭包的注意点
由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法时，在退出函数之前，将不使用的局部变量全部删除。
闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。