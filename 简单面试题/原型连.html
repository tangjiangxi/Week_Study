<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h2>创建对象的几种方法</h2>
    <span>
        1.对象字面量 new创建<br>
        2.显示的构造函数创建对象 new创建<br>
        3.var P={name:'tangjiangxi'}     var p=Object.create(P)
    </span>
    <h2>原型，构造函数，实例，原型链</h2>
    <span>
        实例是由new一个构造函数创建的<br>
        构造函数，创建一个prototype对象，指向原型对象，原型对象的construtor(构造器)，指向构造函数。<br>
        由构造函数创建的实例属性会存在一个_proto_属性指向构造函数的原型
    </span>
    <h2>原型链</h2>
    <span>
        __proto__是实现原型链的关键，而prototype则是原型链的组成。<br>
        instanceof判断实例对象是不是有构造函数创建来的，实际上是判断，实例的_prpto_与构造函数的prototype对象是否指向同一个地址<br>
    </span>
    <h2>new 运算符</h2>
    <span>
        步骤一：创建一个新对象，继承构造函数的原型对象<br>
        步骤二：构造函数被执行，执行的时候，新印的参数被传入，同时上下（this）被指定到实例<br>
        步骤三:如果构造函数返回一个对象，那么这个对象就会取代整个new出来的结果。如果构造函数没有返回对象<br>
            new出来的结果为步骤一的对象。
    </span>
    <script>
        var M=function(){};
        var new1=function(func){
            var o=Object.create(func.prototype);
            var k=func.call(o);
            if(typeof k=="object"){
                return key;
            }else{
                return o;
            }
        }
        var o=new1(M);
    </script>
</body>
</html>